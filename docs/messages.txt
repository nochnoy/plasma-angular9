
	Реализация дерева сообщений на клиентской  стороне

_______________________________________________________________________________

	ОБЗОР

Есть модель сообщения (класс Message).
Содержит ссылку на родительское сообщение и список дочерних сообщений. Так они связываются в иерархию.

Есть модель треда (класс Thread).
Содержит ссылку на рутовое сообщение, хэш всех участвующих в треде сообщений (ключ - их id), функции добавления/удаления/сортировки сообщений, а также создания тредов-дайджестов (см) и схлопов (см) внутри них.

Есть модель канала (класс Channel).
Содержит массив тредов и функцию их десериализации.

Вывод сообщений происходит при помощи компонента MessageListComponent, который в качестве параметра берёт одномерный массив сообщений. Такой массив есть у каждого сообщения - это массив их детей. Соответственно компонент рекурсивно вызывает сам себя и строит дерево.

	ПОСТРОЕНИЕ МОДЕЛИ ДЕРЕВА

Сервер не собирает полноценное дерево, он присылает список сообщений самого верхнего уровня, а в них наваливает вперемешку всех их детей. Получается вот такая двухуровневая иерархия:

<сообщения_канала>
  <рутовое_сообщение>
    <дети>
      <ребёнок />
      <ребёнок />
      <ребёнок />
      ...
    </дети>
  </рутовое_сообщение>
  <рутовое_сообщение>
     ...
  </рутовое_сообщение>
  ...
</сообщения_канала>

У каждого сообщения есть id, parentId и rootId. Соответственно, при десериализации треда, сообщения находят друг друга при помощи функции Thread.getOrCreateMessage() и эта двухуровневая иерархия превращается в полноценное дерево.

Важно:
Сортировка сообщений происходит по id а не по дате.
Причём дайджесты оказываются выше простых тредов и они между собой сортируются уже не по id а по id самого свежего звезданутого сообщения в них.

	ПОСТРОЕНИЕ ДАЙДЖЕСТОВ

Если в канале есть сообщения, которых юзер ещё не видел (сообщения со звёздочками), их нужно вывести на верху канала, чтобы юзер увидел, что произошло пока его не было. Но отобразить сами новые сообщения мало. Нужен ещё контекст - на что люди отвечали, как беседа пришла к этим новым сообщениям. Для этого строятся "дайджесты" - серые копии тредов, в которых показаны (серые) сообщения, которые нужны для того, чтобы показать этот контекст, и сами сообщения со звёздочками (чёрные). Правило, по которому сообщения попадают в дайджест, такое:
- если у сообщения есть звёздочка
- если это рутовое сообщение треда
- если сообщение находится на пути от рутового до звезданутого и:
    звезданутое является его непосредственным ребёнком
    или
    на нём происходит разветвление к двум разным звезданутым

Делается всё это в несколько этапов.

Сначала (при десериализации модели треда) находим в треде звезданутые сообщения и набираем их в массив Thread.starred.

Потом (в Thread.buildDigest()) бежим от этих сообщений вверх по их родителям, клонируем их и закидываем копии в новый тред-дайджест. В результате в дайджесте оказывается дерево из только тех сообщений, которые нужны чтобы добраться от рута до звезданутых.

Внимание: в рамках одного треда не может быть сообщений с одинаковыми id, на это расчитан хеш треда. Но в разных тредах (например в треде и его дайджесте) сообщения с одинаковыми id могут и будут быть.

Дальше происходит жуткая операция под названием "схлоп". Дело в том, что нет нужды показывать юзеру всех предшественников звезданутых сообщений - нужны только звезданутые, их непосредственные родители, рутовое и сообщения-узлы (в том случае, если в треде есть сразу несколько звезданутых, развешенных на разных ветвях).

Схлоп (класс Shlop) - это отрезок "ненужных" сообщений дайджест-треда, которые вырезаются, а на их место вешается кнопка "развернуть" (класс ShlopMessage). По нажатию на кнопку, она будет заменена на хранящийся в ней схлоп.

Собственно, на рутовое сообщение собранного дайджест-треда натравливается функция Thread.findShlops(), которая спускается вниз по детям (распадаясь на рекурсии когда встречает ответвления), находит "ненужные" отрезки дерева и записывает их в схлопы.

После этого мы пробегаемся по массиву схлопов и схлопываем их (вырезаем из дерева и встраиваем на их место ShlopMessage'ы).
Важно: схлоп-мообщение получает id первого сообщения в схлопе, чтобы сохранить правильную последовательность сообщений.
